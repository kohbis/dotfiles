#!/usr/bin/env node

import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const AI_CONTEXT_DIR = path.join(__dirname, '..', '.ai-context');
const CONFIG_FILE = path.join(AI_CONTEXT_DIR, 'config.json');

/**
 * ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
 */
async function backupFile(filePath, backupDir) {
  try {
    const content = await fs.readFile(filePath, 'utf-8');
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
    const backupFileName = `${path.basename(filePath)}.${timestamp}`;
    const backupPath = path.join(AI_CONTEXT_DIR, backupDir, backupFileName);

    await fs.mkdir(path.dirname(backupPath), { recursive: true });
    await fs.writeFile(backupPath, content, 'utf-8');

    console.log(`  Backed up: ${backupFileName}`);
  } catch (err) {
    // ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—ï¼ˆåˆå›å®Ÿè¡Œæ™‚ãªã©ï¼‰
    if (err.code !== 'ENOENT') {
      console.warn(`  Warning: Backup failed for ${path.basename(filePath)}: ${err.message}`);
    }
  }
}

/**
 * ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã‚’äººé–“ãŒèª­ã¿ã‚„ã™ã„å½¢å¼ã§å–å¾—
 */
async function getFileSize(filePath) {
  try {
    const stats = await fs.stat(filePath);
    const bytes = stats.size;
    if (bytes < 1024) return `${bytes} B`;
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
    return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
  } catch (err) {
    return 'N/A';
  }
}

/**
 * ãƒ¡ã‚¤ãƒ³å‡¦ç†
 */
async function main() {
  console.log('ğŸ”„ AI Context Sync Starting...\n');

  // 1. config.jsonèª­ã¿è¾¼ã¿
  let config;
  try {
    const configContent = await fs.readFile(CONFIG_FILE, 'utf-8');
    config = JSON.parse(configContent);
    console.log('âœ“ Loaded config.json');
  } catch (err) {
    console.error(`âŒ Error: Failed to load config.json`);
    console.error(`   ${err.message}`);
    console.error(`\nğŸ’¡ Hint: Run this command from the project root, or ensure .ai-context/config.json exists`);
    process.exit(1);
  }

  // 2. base.mdèª­ã¿è¾¼ã¿
  let baseContent;
  try {
    const basePath = path.join(AI_CONTEXT_DIR, config.base.file);
    baseContent = await fs.readFile(basePath, 'utf-8');
    console.log('âœ“ Loaded base.md\n');
  } catch (err) {
    console.error(`âŒ Error: Failed to load ${config.base.file}`);
    console.error(`   ${err.message}`);
    console.error(`\nğŸ’¡ Hint: Create .ai-context/base.md with common content first`);
    process.exit(1);
  }

  // 3. å„ãƒ„ãƒ¼ãƒ«ã®å‡¦ç†
  const results = [];

  for (const [toolName, toolConfig] of Object.entries(config.tools)) {
    if (!toolConfig.enabled) {
      console.log(`âŠ˜ Skipped: ${toolName} (disabled)`);
      continue;
    }

    console.log(`ğŸ“ Processing: ${toolName}`);

    // a. overrideèª­ã¿è¾¼ã¿
    let overrideContent = '';
    try {
      const overridePath = path.join(AI_CONTEXT_DIR, toolConfig.overrideFile);
      overrideContent = await fs.readFile(overridePath, 'utf-8');
      console.log(`  âœ“ Loaded ${toolConfig.overrideFile}`);
    } catch (err) {
      if (err.code === 'ENOENT') {
        console.log(`  âš  Warning: ${toolConfig.overrideFile} not found, using base.md only`);
      } else {
        console.warn(`  âš  Warning: Failed to read override: ${err.message}`);
      }
    }

    // b. ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
    const outputPath = path.join(AI_CONTEXT_DIR, toolConfig.outputPath);
    if (config.sync.backupBeforeSync) {
      await backupFile(outputPath, config.sync.backupDir);
    }

    // c. ãƒãƒ¼ã‚¸
    const merged =
      toolConfig.autoGeneratedNotice +
      toolConfig.header +
      '\n---\n\n' +
      baseContent +
      (overrideContent ? '\n---\n\n' + overrideContent : '') +
      toolConfig.footer;

    // d. æ›¸ãè¾¼ã¿
    try {
      await fs.mkdir(path.dirname(outputPath), { recursive: true });
      await fs.writeFile(outputPath, merged, 'utf-8');
      const size = await getFileSize(outputPath);
      console.log(`  âœ“ Generated: ${toolConfig.outputPath} (${size})`);
      results.push({ tool: toolName, path: toolConfig.outputPath, size, status: 'success' });
    } catch (err) {
      console.error(`  âŒ Failed to write ${toolConfig.outputPath}: ${err.message}`);
      results.push({ tool: toolName, path: toolConfig.outputPath, status: 'failed', error: err.message });
    }

    console.log('');
  }

  // 4. ãƒ¬ãƒãƒ¼ãƒˆå‡ºåŠ›
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
  console.log('ğŸ“Š Sync Summary\n');

  const successful = results.filter(r => r.status === 'success');
  const failed = results.filter(r => r.status === 'failed');

  if (successful.length > 0) {
    console.log(`âœ… Successfully generated ${successful.length} file(s):`);
    successful.forEach(r => {
      console.log(`   â€¢ ${r.path} (${r.size})`);
    });
  }

  if (failed.length > 0) {
    console.log(`\nâŒ Failed to generate ${failed.length} file(s):`);
    failed.forEach(r => {
      console.log(`   â€¢ ${r.path}: ${r.error}`);
    });
  }

  if (config.sync.backupBeforeSync) {
    console.log(`\nğŸ’¾ Backups saved to: ${config.sync.backupDir}/`);
  }

  console.log('\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');

  if (failed.length > 0) {
    console.log('\nâš ï¸  Some files failed to generate. Please check the errors above.');
    process.exit(1);
  } else {
    console.log('\nâœ¨ All done! AI context files are now in sync.');
  }
}

// ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
main().catch(err => {
  console.error('\nğŸ’¥ Unexpected error:', err.message);
  console.error(err.stack);
  process.exit(1);
});
